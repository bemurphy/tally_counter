{"name":"Tally counter","tagline":"Tally web application hits with Rack & Redis sorted sets","body":"# TallyCounter\r\n\r\nTally web application hits with Rack & Redis sorted sets\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'tally_counter'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install tally_counter\r\n\r\n## Usage\r\n\r\nIn your `config.ru` or middleware configuration:\r\n\r\n```ruby\r\nuse TallyCounter::Middleware\r\n\r\n# Options\r\n\r\n# Provide a Redis instance\r\nuse TallyCounter::Middleware, :redis => $redis\r\n\r\n# Use a 15 minute interval window\r\nuse TallyCounter::Middleware, :interval => 900\r\n\r\n# Use a namespace prefix for keys\r\nuse TallyCounter::Middleware, :namespace => 'my_app_name'\r\n\r\n# Timeout to Redis in 0.001 seconds\r\nuse TallyCounter::Middleware, :timeout => 0.001\r\n\r\n# Inject a logger\r\nuse TallyCounter::Middleware, :logger => some_logger\r\n```\r\n\r\nIt is adviseable you configure `TallyCounter::Middleware` before\r\nyour main application (so Rails, Sinatra, etc) but after your\r\nstatic/cache layer.  You probably don't want to be tracking hits\r\nagainst CSS, js, etc.\r\n\r\nIf you wish to avoid counting actions from further down the stack,\r\nyou may inject a response header:\r\n\r\n```ruby\r\nheaders['X-Tally-Counter-Skip'] = 'true'\r\n```\r\n\r\nNote the mere presence of the header and not its value is enough\r\nto cause a count skip.\r\n\r\n## Keys and Scoring\r\n\r\nThe system uses Redis sorted sets for tracking application hits.\r\nFor each request, a key will be generated, and the score for the\r\nremote request ip will be incremented by 1.\r\n\r\nKeys are generated like 'tally_counter:1371283200' where the time\r\nis the epoch seconds floor for the current window.  The floor for\r\na 5 minute interval at 12:38 would be 12:35, at 12:33 it's 12:30,\r\nand so on.\r\n\r\nIt is recommended to use a scheduled process to inspect tally_counter\r\nsets past a certain age (say, 3 days) and prune them to keep your\r\ndata set small and clean.\r\n\r\nFinding totals for a range of time can be accomplished via a Redis\r\nzunionstore on a range of keys.  For example, if you have a a 5\r\nminute interval and want to see the last 15 minutes, simple grab\r\nthe current window and the 2 previous and union them with equally\r\nweighted scoring.  See `TallyCounter::Window#floow` for generating\r\nwindow times and offsets.\r\n\r\n## Reporting\r\n\r\nIn the interest of giving this gem a single responsibility, reporting\r\ncan be offloaded to other systems.  It should be easy to deploy\r\na separate admin application connected to the same server, and use\r\nthe `TallyCounter::Window` class for generating keys.\r\n\r\n## Todo\r\n\r\nExtract key generation to a utility for use by middleware and client\r\napps.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}